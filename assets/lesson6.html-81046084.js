import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,d as e}from"./app-434ca933.js";const t={},o=e(`<h1 id="metodusok" tabindex="-1"><a class="header-anchor" href="#metodusok" aria-hidden="true">#</a> Metódusok</h1><div class="hint-container note"><p class="hint-container-title">Röviden</p><ul><li>A metódusok lehetővé teszik, hogy elnevezzük és újrahasznosítsuk a kódrészleteket.</li><li>A paraméterek lehetővé teszik a metódusnak, hogy különböző adatokkal dolgozzon minden egyes híváskor.</li><li>A metódusok eredményt állítanak elő visszatérési értékkel.</li><li>Két metódus ugyanazzal a névvel rendelkezhet (<em>metódus túlterhelés - overload</em>), ha a paramétereik különbözőek.</li><li>Néhány egyszerű metódust kifejezésként lehet definiálni</li></ul></div><p>Ahogy egyre több eszközt gyűjtöttünk össze a készletünkbe, úgy bővülnek a programjaink is. El kell kezdenünk megtanulni, hogyan kezdjük el rendszerezni a kódunkat. A C#-nak elég sok eszköze van a kódszervezésre, de az első, amit megtanulunk, az a metódus.</p><p>Már eddig is használtunk és hoztunk létre metódusokat. Például használtuk a <code>Console</code> osztálynak a <code>WriteLine</code> metódusát és a <code>Convert</code> osztákynak <code>ToInt32</code> metódusát is. Minden általunk készített programnak volt egy <code>Main</code> metódusa, amely tartalmazta az általunk írt kódot és a programunk belépési pontja.</p><p>Most azt fogjuk megvizsgálni, hogyan készíthetünk további metódusokat és hogyan használhatjuk ezt arra, hogy apró és újrafelhasználható elemekre bontsuk a kódunkat.</p><h2 id="metodus-definialasa" tabindex="-1"><a class="header-anchor" href="#metodus-definialasa" aria-hidden="true">#</a> Metódus definiálása</h2><p>Egy új metódus létrehozásához meg kell értenünk, hogy hol és hogyan kell létrehozni. Az alábbi kód ennek egy lehetséges módját mutatja be:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CountToTen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> current <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> current <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> current<span class="token operator">++</span><span class="token punctuation">)</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A <code>void CountToTen()</code> sor, a kapcsos zárójelek és az között, minden ami van egy új metódust határoz meg. Egyelőre koncentráljunk erre a <code>void CountToTen()</code> sorra. Ez a sor deklarálja vagy létrehozza a metódust és meghatározza, hogyan kell használni.</p><p><code>CountToTen</code> a metódus neve. A változókhoz hasonlóan nagy rugalmassággal rendelkezünk az elnevezésében, de a C# programozók többsége <strong>UpperCamelCase</strong>-t használ minden metódusnevéhez.</p><p>A <code>void</code> rész, a név előtt, a metódus visszatérési típusa. Ezzel később részletesebben foglalkozunk. Egyelőre csak annyit kell tudnunk, hogy a <code>void</code> azt jelenti, hogy a metódus nem ad vissza eredményt.</p><p>Minden metódusdeklaráció tartalmaz egy zárójelbe tett információhalmazt, amelyet a metódus használ. A <code>CountToTen</code>-nek nincs szüksége semmilyen információra a feladatának elvégzéséhez, ezért egyelőre üresen hagytuk a zárójeleket.</p><p>A deklaráció után következik a metódus törzse, amely tartalmazza az összes kódot, amelynek futnia kell, amikor meghívjuk. Ebben az esetben a törzs a kapcsos zárójelek és az azok között minden az utasítás. A múltban használt összes kódot - ciklusok, <code>if</code>-ek, <code>Console.WriteLine</code> hívások stb. - használhatjuk bármelyik általunk létrehozott metódusban.</p><div class="hint-container info"><p class="hint-container-title">Helyi függvények</p><p>A fenti <code>CountToTen</code> definíciója a <code>Program</code> osztályon belül helyezkedik el. Amikor elkezdünk osztályokat készíteni, szinte minden metódusunk egy osztályban fog elhelyezkedni.</p></div><h2 id="metodus-hivasa" tabindex="-1"><a class="header-anchor" href="#metodus-hivasa" aria-hidden="true">#</a> Metódus hívása</h2><p>A fenti kódunk definiált egy <code>CountToTen</code> metódust, de nem használtuk. Javítsuk ki ezt. Már hívtunk metódusokat korábban, mint például a <code>Console.WriteLine</code>, így a szintaxis ismerős kell, hogy legyen:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token function">CountToTen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CountToTen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> current <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> current <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> current<span class="token operator">++</span><span class="token punctuation">)</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A legjelentősebb különbség, hogy nem tettünk osztálynevet, ahogy azt a <code>Console.WriteLine</code>-nál tettük. Mivel bárhonnan hivatkozhatunk rá a fő metódusban.</p><p>Fontos megjegyezni, hogy az, hogy a <code>CountToTen</code> definíciója a metódus végén található, nem jelenti azt, hogy akkor hívódik meg. Csak egy tényleges metódus hívás indítja el a metódust. Egy definíció önmagában nem elegendő ehhez.</p><p>Természetesen többször is hívhatjuk az új metódusunkat. A kód újrafelhasználása az elsődleges ok a metódusok használatára.</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token function">CountToTen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">CountToTen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CountToTen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> current <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> current <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> current<span class="token operator">++</span><span class="token punctuation">)</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Most már láthatjuk, hogy mennyire hasznosak a metódusok. Egy csomó utasítást össze tudunk csomagolni egy helyre és el tudjuk nevezni azt. Futtathatjuk, amikor szükségünk van rá. Újrahasználhatjuk anélkül, hogy másolnánk és beillesztenénk.</p><h3 id="a-metodusok-sajat-valtozokat-kapnak" tabindex="-1"><a class="header-anchor" href="#a-metodusok-sajat-valtozokat-kapnak" aria-hidden="true">#</a> A metódusok saját változókat kapnak</h3><p>A metódusok saját változókat kapnak, amelyekkel dolgozhatnak. Ezáltal nem avatkoznak egy másik metódus adataiba. Több metódus is használhatja ugyanazt a változónevet és nem zavarják egymást:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">int</span></span> current <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">CountToTen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">CountToTwenty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CountToTen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> current <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> current <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> current<span class="token operator">++</span><span class="token punctuation">)</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CountToTwenty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> current <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> current <span class="token operator">&lt;=</span> <span class="token number">20</span><span class="token punctuation">;</span> current<span class="token operator">++</span><span class="token punctuation">)</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A <code>CountToTen</code>, <code>CountToTwenty</code> és a <code>Main</code> metódus mindegyike rendelkezik egy <code>current</code> változóval, de a három változó különbözik egymástól. Mindegyiknek saját memóriahelye van a változónak és nem befolyásolja a többit. Ez a szétválasztás lehetővé teszi, hogy egyszerre csak egy metóduson dolgozzunk anélkül, hogy aggódnánk amiatt, hogy mi történik a többi metódusban. Nem kell egyszerre az egész program működését a fejünkben tartani.</p><h2 id="adatok-atadasa-a-metodusnak" tabindex="-1"><a class="header-anchor" href="#adatok-atadasa-a-metodusnak" aria-hidden="true">#</a> Adatok átadása a metódusnak</h2><p>Ha egy metódusnak adatra van szüksége a feladatához, akkor definiálhatunk speciális változókat, amelyeket paramétereknek nevezünk és ezekben tárolhatjuk az adatokat. A változóktól eltérően, a hívó metódus inicializálja ezeket a változókat, amikor a metódus meghívódik. (<em>Egyébként a változók, amelyek nem paraméterek - azokat használtuk eddig - helyi változóknak hívják.</em>) A paraméterek rugalmasságot adnak a metódusoknak.</p><p>Korábban definiáltunk egy <code>CountToTen</code> és egy <code>CountToTwenty</code> metódust. Paraméterekkel mindkettőt helyettesíthetjük egyetlen metódussá. A paramétereket a metódus zárójelei között határozzuk meg:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> numberToCountTo<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> current <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> current <span class="token operator">&lt;=</span> numberToCountTo<span class="token punctuation">;</span> current<span class="token operator">++</span><span class="token punctuation">)</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Ezt a <code>numberToCountTo</code> paramétert a metóduson belül használhatjuk, mint bármely más változót. A paramétereket nem kell inicializálnunk a metóduson belül, a hívó metódus inicializálja őket, amikor a metódushívás elkezdődik, úgy, hogy az értékeket (<em>vagy kiértékelendő kifejezéseket</em>) zárójelek közé helyezzük:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token function">Count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Count</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>A hívó metódus által a metódushívásban megadott érték egy argumentum. Tehát az első sorban a <strong>10</strong> az egy argumentum a <code>numberToCountTo</code> paraméterhez. A második sorban a <strong>20</strong> szintén argumentum. A programozók ezt úgy is nevezhetik, hogy adatokat adnak át a metódusnak. Azt mondhatnák, hogy „<em>Az első sorban átadjuk a 10-et, a második sorban pedig a 20-at.</em>” Ezzel a kóddal a programunk először <strong>10</strong>-ig, majd utána <strong>20</strong>-ig fog számolni. Ez a <code>Count</code> metódus lehetővé teszi, hogy gyakorlatilag bármelyik pozitív számig számoljunk.</p><p>Már láttuk ezt a mechanizmust korábban. A <code>Console WriteLine</code> metódusának van egy érték paramétere. Amikor meghívjuk a <code>Console.WriteLine(&quot;Hello, World!&quot;)</code> metódust, akkor csak átadjuk a <code>&quot;Hello, World!&quot;</code> argumentumot.</p><h3 id="tobb-parameter" tabindex="-1"><a class="header-anchor" href="#tobb-parameter" aria-hidden="true">#</a> Több paraméter</h3><p>Egy metódusnak annyi paramétere lehet, amennyire szükségünk van. Ha két darab információra van szükségünk egy feladat elvégzéséhez, akkor két paraméterünk lehet. Ha húsz darab információra van szükségünk, akkor húsz paraméterünk lehet. Ha 200 paraméterre van szükségünk... (<em>nos, valószínűleg szükségünk van valakire, aki felébreszt minket ebből az álmoból amiben most vagyunk, de meg tudjuk csinálni.</em>) Több mint egy maroknyi paraméter általában azt jelenti, hogy másképpen kell felbontanunk a problémánkat. Elég nehéz megjegyezni, hogy mi mit csinál ennyi paraméterrel...</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">CountBetween</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> start<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> current <span class="token operator">=</span> start<span class="token punctuation">;</span> current <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> current<span class="token operator">++</span><span class="token punctuation">)</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A több paramétert igénylő metódus hívása úgy történik, hogy az értékeket a zárójelben lévő megfelelő helyekre helyezzük, vesszővel elválasztva:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token function">CountBetween</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="adatok-visszaadasa" tabindex="-1"><a class="header-anchor" href="#adatok-visszaadasa" aria-hidden="true">#</a> Adatok visszaadása</h2><p>A paraméterek lehetővé teszik, hogy adatokat küldjünk át a meghívott metódusnak, a visszatérési értékek pedig lehetővé teszik, hogy a metódus adatokat küldjön vissza a hívó metódusnak. Egy visszatérési érték lehetővé teszi, hogy a metódus eredményt állítson elő, amikor befejeződik. A múltban már láttunk visszatérési értékeket. Például a két alábbi metódus visszatérési értékeit használjuk:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">string</span></span> input <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">int</span></span> number <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Ahhoz, hogy egy metódus visszaadjon egy értéket, két dolgot kell tennünk. Először is meg kell adnunk az adattípusát, másodszor pedig meg kell adnunk, hogy milyen váltózót adjon vissza:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">ReadNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">string</span></span> input <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">int</span></span> number <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Ahelyett, hogy <code>void</code> visszatérési típus lenne, ez a metódus azt jelzi, hogy <code>int</code>-et ad vissza a befejezéskor. Ezután felhasználhatjuk a visszaadott értéket a <code>ReadNumber</code> meghívásakor, ahogy korábban is tettük:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code>Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">&quot;How high should I count?&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">int</span></span> chosenNumber <span class="token operator">=</span> <span class="token function">ReadNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Count</span><span class="token punctuation">(</span>chosenNumber<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> numberToCountTo<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> current <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> current <span class="token operator">&lt;=</span> numberToCountTo<span class="token punctuation">;</span> current<span class="token operator">++</span><span class="token punctuation">)</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">ReadNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">string</span></span> input <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">int</span></span> number <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="adatok-korai-visszaadasa" tabindex="-1"><a class="header-anchor" href="#adatok-korai-visszaadasa" aria-hidden="true">#</a> Adatok korai visszaadása</h3><p>Egy <code>return</code> utasítás egy metódus utolsó sorában gyakori, de egy <code>return</code> utasítás bárhol előfordulhat egy metódusban. A metódus utolsó sora előtti visszatérést korai &quot;<em>visszatérésnek</em>&quot; vagy korai kilépésnek nevezzük. A korai visszatérés különösen gyakori, ha ciklusokat és elágazásokat használunk a kódunkban. Az alábbi metódus ismételten kérni fog egy nevet, amíg a felhasználó nem ír be valamilyen tényleges szöveget a puszta <em>Enter</em> leütése helyett:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">GetUserName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">&quot;What is your name? &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name"><span class="token keyword">string</span></span> name <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">!=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span> <span class="token comment">// Empty string</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Let&#39;s try that again.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Amikor egy <code>return</code> utasítás elérésre kerül, a végrehajtás folyamta azonnal elhagyja a metódust, attól függetlenül, hogy az a metódus utolsó sora-e vagy sem. Bár a <code>return</code> utasítások bárhol előfordulhatnak egy metódusban, minden útvonalnak meg kell határoznia a visszaadott értéket. Azzal, hogy egy nem-<code>void</code> visszatérési típust adsz meg, ígéretet teszel egy eredmény előállítására. Ezt az ígéretet be kell tartanod, bármilyen <code>if</code> utasításokkal és ciklusokkal is találkozol.</p><p>Egy olyan metódus, amelynek visszatérési típusa <code>void</code>, azt jelzi, hogy nem állít elő vagy nem ad vissza értéket. Ezek egyszerűen futnak a metódus végéig, <code>return</code> utasítások nélkül. Azonban a <code>void</code> metódusok is korán visszatérhetnek egy egyszerű <code>return</code> utasítással:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> numberToCountTo<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>numberToCountTo <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> index <span class="token operator">&lt;=</span> numberToCountTo<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> 
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="tobb-visszateresi-ertek" tabindex="-1"><a class="header-anchor" href="#tobb-visszateresi-ertek" aria-hidden="true">#</a> Több visszatérési érték?</h3><p>A C#-ban, mint sok programozási nyelvben, egyszerre nem adhatsz vissza több dolgot. De ez a korlátozás rosszabbnak hangzik, mint amilyen. Többféle módon is kikerülhetjük. Hamarosan látni fogjuk, hogyan csomagolhatunk több adatot egyetlen változóba, kezdve a tuple-ökkel, folytatva az osztályokkal. Bár technikailag csak egyetlen elemet adhatunk vissza.</p><h2 id="metodus-tulterheles" tabindex="-1"><a class="header-anchor" href="#metodus-tulterheles" aria-hidden="true">#</a> Metódus túlterhelés</h2><p>Minden metódusnak, amit létrehozol, egyedi nevet kell adnod, ami leírja, mit csinál. Azonban néha előfordul, hogy két metódus lényegében ugyanazt a feladatot végzi, csak kissé eltérő paraméterekkel. Két metódus neve megegyezhet, amíg a paraméterlistáik különbözőek. A név megegyezést <strong>metódus túlterhelés</strong>-nek nevezzük.</p><p>Egy jó példa a <code>Console</code> osztály <code>WriteLine</code> metódusa, amelynek sok túlterhelése van. Ez teszi lehetővé, hogy a következő működjön:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Welcome to my evil lair!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Van egy <code>WriteLine</code> verzió, amelynek egy <code>string</code> paramétere és egy, amelynek egy <code>int</code> paramétere van.</p><p>Amikor a fordító egy túlterhelt metódus hívásával találkozik, ki kell találnia, hogy melyik túlterhelést kell használnia. Ezt a folyamatot túlterhelés feloldásnak nevezik. Ez egy bonyolult téma, tele árnyalatokkal a trükkös helyzetekhez, de az egyszerű verzió az, hogy általában meg tudja mondani, hogy melyiket akarod a típusok és az argumentumok száma alapján. Amikor írjuk a <code>Console.WriteLine(42)</code>-t, a fordító a <code>WriteLine</code> verziót választja, amelynek egyetlen <code>int</code> paramétere van.</p><p>A <code>Console.WriteLine</code>-nek összesen <strong>18</strong> különböző túlterhelése van. A legtöbbnek egyetlen paramétere van, mindegyik más típusú (<code>string</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <em>stb.</em>), de van egy túlterhelés, amelynek nincs paramétere (<code>Console.WriteLine()</code>), ami csak a következő sorra lép. A metódusnév összes túlterhelésének halmazát metóduscsoportnak nevezzük.</p><h2 id="metodusok-kifejezesekkel" tabindex="-1"><a class="header-anchor" href="#metodusok-kifejezesekkel" aria-hidden="true">#</a> Metódusok kifejezésekkel</h2><p>Néhány metódus olyan egyszerű, hogy a metódus lényege elveszik a meghatározásának módjában. Például nézzük meg ezt a <code>DoubleAndAddOne</code> metódust:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">DoubleAndAddOne</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> <span class="token keyword">value</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">value</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Ha egy metódust egy kifejezéssel le tudunk írni, akkor van egy egyszerűbb módja is annak megírásának:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">DoubleAndAddOne</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">value</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Ebben a formátumban nem kell kapcsos zárójelet és <code>return</code> utasítást használnunk, csak a <code>=&gt;</code> jelet és a kifejezést, amit ki akarunk számolni és a végére egy pontosvesszőt. A <code>DoubleAndAddOne</code> két változata ugyanazt csinálja. Az első változatnak blokkteste van, a másodiknak meg kifejezésteste. A <code>=&gt;</code> jel azt jelenti, hogy most jön egy kifejezés. Ezt a jelet már láttuk a <code>switch</code> kifejezéseknél is és még fogjuk is.</p><p>Ha több utasításra van szükségünk, akkor blokktestet kell használnunk. A következő példa bár rövid, de nem írható le kifejezéssel:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">PrintTwice</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> message<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Sok C# programozó előnyben részesíti a kifejezéseket, ha lehetséges, mert rövidebbek és könnyebben érthetőek - <em>legalábbis ha már megbarátkoztál a kifejezésszintaxissal</em>.</p><h2 id="xml-dokumentacio" tabindex="-1"><a class="header-anchor" href="#xml-dokumentacio" aria-hidden="true">#</a> XML Dokumentáció</h2><p>Az eddigiekben megtanultuk, hogyan adjunk hozzá megjegyzéseket a kódunkhoz a <code>//</code> és a <code>/* ... */</code> jelekkel. Most nézzük meg egy másik lehetőséget.</p><p>A metódusok segítenek nekünk olyan kódot írni, amit mások is könnyen használhatnak. Vannak olyan kódok, amiket sokan használnak, akár a világ másik felén is. A <code>Console</code> és a <code>Convert</code> ilyenek. Vannak olyan eszközök, amik átnézik a C# kódunkat és összegyűjtik a metódusainkhoz és más dolgokhoz tartozó megjegyzéseket, hogy dokumentációt készítsenek róluk. Ahhoz, hogy ezek az eszközök jól működjenek, a megjegyzéseinket egy bizonyos formában kell írnunk, amit az eszközök felismernek és megértenek. Erre valók az <strong>XML</strong> dokumentációs megjegyzések.</p><p>Az <strong>XML</strong> dokumentációs megjegyzések használatának legegyszerűbb módja az, ha a metódusunk neve előtti sorba beírunk három perjelet (<code>/</code>): <code>///</code>. Ha ezt megcsináljuk, a Visual Studio készít nekünk egy több soros megjegyzést, ami egy sablon, amit ki tudunk tölteni. Például így néz ki egy egyszerű <strong>XML</strong> dokumentációs megjegyzés a <code>Count</code> metódushoz:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token doc-comment comment">/// <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>summary</span><span class="token punctuation">&gt;</span></span></span>
<span class="token doc-comment comment">/// Counts to the given number, starting at 1 and including the number provided.</span>
<span class="token doc-comment comment">/// <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>summary</span><span class="token punctuation">&gt;</span></span></span>
<span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> numberToCountTo<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> index <span class="token operator">&lt;=</span> numberToCountTo<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> 
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Ezek a dokumentációs megjegyzések <strong>XML</strong> alapúak, ezért így néznek ki. Ha nem ismered az <strong>XML</strong>-t, érdemes utánanézned. Ha kitöltjük ezeket a megjegyzéseket, akkor az eszközök használni tudják őket a dokumentációhoz, beleértve a Visual Studio-t is.</p>`,76),p=[o];function l(c,i){return s(),a("div",null,p)}const r=n(t,[["render",l],["__file","lesson6.html.vue"]]);export{r as default};
