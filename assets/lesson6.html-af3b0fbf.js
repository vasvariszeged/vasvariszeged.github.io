import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,d as t}from"./app-434ca933.js";const n="/assets/images/vasvari/csharp/typeofcsharp.png",o={},l=t(`<h1 id="a-c-tipusok" tabindex="-1"><a class="header-anchor" href="#a-c-tipusok" aria-hidden="true">#</a> A C# típusok</h1><div class="hint-container note"><p class="hint-container-title">Röviden</p><ul><li>A változók és értékek típusai a C# nyelvben – nem felcserélhetők egymással.</li><li>Nyolc egész szám típus létezik különböző méretű és tartományú egész számok tárolására: <code>int</code>, <code>short</code>, <code>long</code>,<br><code>byte</code>, <code>sbyte</code>, <code>uint</code>, <code>ushort</code> és <code>ulong</code>.</li><li>A <code>char</code> típus karakterek tárolására szolgál.</li><li>A <code>string</code> típus hosszabb szöveget tárol.</li><li>A valós számok tárolására három típus létezik: <code>float</code>, <code>double</code> és <code>decimal</code>.</li><li>A <code>bool</code> típus a logikában használt igazságértékeket (<em>true</em> és <em>false</em>) tárolja.</li><li>Ezek a típusok egy sokkal nagyobb típusrendszer építőkövei.</li><li>A <code>var</code> használata egy változó típusnál azt jelenti, hogy a fordító a környező kódból következtet a típusára, így nem kell begépelnünk.</li><li>A <code>Convert</code> osztály segít az egyik típust egy másikba konvertálni.</li></ul></div><p>A C# nyelvben a változók és az értékek típusai meg kell, hogy egyezzenek, de eddig csak két típust ismertünk meg. Most megnézzük a típusok változatos készletét, amelyeket a programjainkban használhatunk. Ezeket a típusokat beépített típusoknak vagy primitív típusoknak nevezzük. Ezek az építőkövei a bonyolultabb típusoknak, amelyekkel később találkozunk.</p><h2 id="az-adatok-abrazolasa-binarisan" tabindex="-1"><a class="header-anchor" href="#az-adatok-abrazolasa-binarisan" aria-hidden="true">#</a> Az adatok ábrázolása binárisan</h2><p>Miért olyan fontosak a típusok?</p><p>Minden adatot, amelyet a programjainkban ábrázolni szeretnénk, a számítógép áramkörében kell tárolni és csak a bináris <strong>1</strong> és <strong>0</strong> értékekre korlátozódik. Ha egy számot akarunk tárolni, akkor szükségünk van egy sémára, amely a bitek (<em>egyetlen 1 vagy 0</em>) és a bájtok (<em>8 bitből álló csoport és a bitek szabványos csoportosítási mérete</em>) használatával reprezentálja a tárolni kívánt lehetséges számok tartományát. Ha egy szót akarunk ábrázolni, akkor szükségünk van valamilyen sémára a bitek és bájtok használatára a betűk és betűsorozatok ábrázolására. Tágabb értelemben bármit, amit egy programban ábrázolni akarunk, szükségünk van egy sémára, amellyel binárisan kifejezhetjük.</p><p>Minden típus saját szabályokat határoz meg az értékek bináris ábrázolására és a különböző típusok nem felcserélhetők egymással. Nem lehet egész számok reprezentálására szánt biteket és bájtokat venni és ezeket a biteket és bájtokat átértelmezni karakterláncként és azt várni, hogy értelmet nyerjünk belőle. Ugyanígy nem vehetünk szöveget reprezentáló biteket és bájtokat és nem értelmezhetjük őket egész számként és nem várhatjuk el, hogy ez értelmes legyen. Ezek nem ugyanazok. Ezt nem lehet megkerülni.</p><p>Ez nem jelenti azt, hogy minden típus egy külön világ, amely soha nem léphet kölcsönhatásba a többi típussal. Gyakran át tudunk és át is fogunk alakítani egyik típusból a másikba. De az átalakulással járó költségek nem ingyenesek, ezért inkább tudatosan tesszük, mint véletlenül.</p><p>Kiemelkedően fontos, hogy a C# nem talál ki teljesen új rendszereket és szabályokat legtöbb típusához. Az informatikai világ kidolgozott rendszereket alkalmaz a gyakori típusokra, mint például számokra és betűkre. A számítógép fizikai hardvere is ugyanezen rendszereket használja. Mivel ezek beépítve vannak az áramkörbe, így ez által gyors működés érhető el.</p><h2 id="integer-tipus" tabindex="-1"><a class="header-anchor" href="#integer-tipus" aria-hidden="true">#</a> Integer típus</h2><p>Nézzük meg a C# programokban elérhető alapvető típusokat, kezdve azokkal, amelyek az egész számokat képviselik. Létezik nyolc különböző típus is az egész számokkal való munkához. Ezt a nyolc típust egész típusoknak vagy integertípusoknak nevezzük. Mindegyik típus más-más számú bájtot használ, ami lehetővé teszi, hogy nagyobb számokat tároljunk több memória felhasználásával, vagy kisebb számokat tároljunk memóriakímélő módon.</p><p>Az <code>int</code> típus <em>4 bájtot</em> használ és számokat képes reprezentálni körülbelül -2 milliárdtól +2 milliárdig.</p><p>Ellentétben a <code>short</code> típussal, amely <em>2 bájtot</em> használ és körülbelül <strong>-32,000</strong>-től <strong>+32,000</strong>-ig terjedő számokat képes reprezentálni, a long típus <em>8 bájtot</em> használ és körülbelül -9 kvintilliótól +9 kvintillióig terjedő számokat képes reprezentálni.</p><p>A méretek és tartományok azt mutatják meg, mikor választhatjuk a <code>short</code> vagy a <code>long</code> típust az <code>int</code> helyett. Ha a memória korlátozott és a <code>short</code> tartománya elegendő, használhatjuk <code>short</code>-ot. Ha olyan számokat kell használnunk, amelyek nagyobbak, mint amit az <code>int</code> kezelne, akkor a <code>long</code> típusra kell váltanunk, még akkor is, ha több bájtba kerül.</p><p>A <code>short</code>, <code>int</code> és <code>long</code> típusok előjeles típusok, pozitív vagy negatív előjelet tartalmaznak és pozitív és negatív értékeket tárolnak.</p><p>Ha csak pozitív számokra van szükségünk, akkor erre szolgálnak az előjel nélküli típusok: <code>ushort</code>, <code>uint</code> és <code>ulong</code>. Ezek mindegyike ugyanannyi bájtot használ, mint az előjeles megfelelőjük, nem tárolhatunk bennük negatív számokat, de cserébe kétszer annyi pozitív számot tárolhatunk. Így az <code>ushort</code> tartománya <strong>0</strong>-tól körülbelül <strong>65 000</strong>-ig, az <code>uint</code> tartománya <strong>0</strong>-tól körülbelül <strong>4</strong> milliárdig, az <code>ulong</code> tartománya pedig <strong>0</strong>-tól körülbelül <strong>18</strong> kvintillióig terjed.</p><p>Az utolsó két egész számtípus egy kicsit más. A <code>byte</code> típus, amely egyetlen bájtot használ a <strong>0</strong> és <strong>255</strong> közötti értékek ábrázolására (<em>előjel nélküli</em>). Habár a byte-típust gyakrabban használják olyan bájtok gyűjteményének kifejezésére, amelyeknek nincs konkrét struktúrájuk (<em>vagy a program nem ismeri őket</em>). A bájt típusnak van egy előjeles megfelelője, az <code>sbyte</code>, amely a <strong>-128</strong> és <strong>+127</strong> közötti értékeket képviseli. Az <code>sbyte</code> típus nem túl gyakran használatos, de teljessé teszi a készletet.</p><p>Az alábbi táblázat összefoglalja ezeket az információkat.</p><table><thead><tr><th>Típus</th><th>Méret (bájt)</th><th>Minimum</th><th>Maximum</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>0</td><td>255</td></tr><tr><td>short</td><td>2</td><td>-32.768</td><td>32.767</td></tr><tr><td>int</td><td>4</td><td>-2.147.483.648</td><td>2.147.483.647</td></tr><tr><td>long</td><td>8</td><td>-9.223.372.036.854.775.808</td><td>9.223.372.036.854.775.807</td></tr><tr><td>sbyte</td><td>1</td><td>-128</td><td>127</td></tr><tr><td>ushort</td><td>2</td><td>0</td><td>65.535</td></tr><tr><td>uint</td><td>4</td><td>0</td><td>4.294.967.295</td></tr><tr><td>ulong</td><td>8</td><td>0</td><td>18.446.744.073.709.551.615</td></tr></tbody></table><h3 id="valtozok-deklaralasa-es-hasznalata-egesz-tipusu-valtozokkal" tabindex="-1"><a class="header-anchor" href="#valtozok-deklaralasa-es-hasznalata-egesz-tipusu-valtozokkal" aria-hidden="true">#</a> Változók deklarálása és használata egész típusú változókkal</h3><p>Az ilyen más típusú változók deklarálása ugyanolyan egyszerű, mint az <code>int</code> vagy <code>string</code> típusok esetén, csak használjuk ezeknek a típusoknak a nevét <code>int</code> vagy <code>string</code> helyett, ahogyan azt korábban is tettük:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">byte</span></span> aSingleByte <span class="token operator">=</span> <span class="token number">34</span><span class="token punctuation">;</span>
aSingleByte <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span>

<span class="token class-name"><span class="token keyword">short</span></span> aNumber <span class="token operator">=</span> <span class="token number">5039</span><span class="token punctuation">;</span>
aNumber <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">4354</span><span class="token punctuation">;</span>

<span class="token class-name"><span class="token keyword">long</span></span> aVeryBigNumber <span class="token operator">=</span> <span class="token number">395904282569</span><span class="token punctuation">;</span>
aVeryBigNumber <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span>
</code></pre><div class="highlight-lines"><div class="highlight-line"> </div><br><br><div class="highlight-line"> </div><br><br><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A múltban láttuk, hogy egy szám közvetlenül kódunkban történő megadása egy <code>int</code> literált hoz létre. De ez felvet egy érdekes kérdést. Hogyan hozhatunk létre olyan literált, amely egy <code>byte</code> literál vagy egy <code>ulong</code> literál?</p><div class="hint-container info"><p class="hint-container-title">literál</p><p>A literál egy konkrét, szó szerinti értéket jelent a programban. Ez lehet egy szám, egy karakter, egy szöveg vagy más adattípus értéke, amelyet közvetlenül a forráskódban adjuk meg. A literálok olyan értékeket képviselnek, amelyek az adott adattípusnak megfelelőek.</p><p>Például:</p><ul><li>Szám literál: <code>42</code> egy egész szám literál.</li><li>Karakter literál: <code>&#39;A&#39;</code> egy karakter literál.</li><li>Szöveg literál: <code>&quot;Hello, World!&quot;</code> egy szöveg literál.</li></ul><p>Tehát a literál a forráskódban szereplő konkrét érték, amely az adott adattípusnak felel meg.</p></div><p>Az <code>int</code>-nél kisebb dolgok esetében nincs szükség semmi különlegesre, az adott típusú literál létrehozásához:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">byte</span></span> aNumber <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>A <strong>32</strong> egy szám literál, de a <em>fordító</em> elég intelligens ahhoz, hogy észrevegye, hogy egy <code>byte</code>-ban próbáljuk tárolni. Ellenőrzi, hogy a <strong>32</strong> megengedett tartományon belül van-e a <code>byte</code> típus esetében. Ellenkező esetben, ha olyan literált használnánk, ami túl nagy a <code>byte</code> típushoz, fordítási hibát kapnánk, ami megakadályozza a programunk fordítását és futtatását.</p><p>Ugyanez a szabály érvényes az <code>sbyte</code>, <code>short</code> és <code>ushort</code> típusokra is.</p><p>Ha a literál érték túl nagy az <code>int</code> típushoz, automatikusan <code>uint</code> literállá, <code>long</code> literállá vagy <code>ulong</code> literállá válik. Fordítói hibát kapunk, ha olyan literált állítunk be, amelynek értéke mindenhez túl nagy. Annak illusztrálására, hogy hogyan működnek ezek a nagyobb literáltípusok, tekintsük meg ezt a kódot:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">long</span></span> aVeryBigNumber <span class="token operator">=</span> <span class="token number">10000000000</span><span class="token punctuation">;</span> <span class="token comment">// 10 billion would be a \`long\` literal.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Előfordulhat, hogy néha azt szeretnénk, hogy egy kisebb szám valamely nagyobb literális típussá váljon. Ezt úgy kényszeríthetjük ki, hogy a szó szerinti érték végére egy <strong>U</strong> vagy <strong>L</strong> (<em>vagy mindkettő</em>) betűt teszünk:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">ulong</span></span> aVeryBigNumber <span class="token operator">=</span> <span class="token number">10000000000U</span><span class="token punctuation">;</span>
aVeryBigNumber <span class="token operator">=</span> <span class="token number">10000000000L</span><span class="token punctuation">;</span>
aVeryBigNumber <span class="token operator">=</span> <span class="token number">10000000000UL</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Az <strong>U</strong> azt jelenti, hogy az érték előjel nélküli és vagy <code>uint</code> vagy <code>ulong</code> kell, hogy legyen. Az <strong>L</strong> azt jelzi, hogy a literálnak <code>long</code>-nak vagy <code>ulong</code>-nak kell lennie, a mérettől függően. Az <strong>UL</strong> azt jelzi, hogy <code>ulong</code>-nak kell lennie. Ezek az utótagok lehetnek nagy- vagy kisbetűsek és bármelyik sorrendben. Kerüljük azonban a kisbetűs <strong>l</strong> használatát, mert az túlságosan úgy néz ki, mint az <strong>1</strong>.</p><div class="hint-container danger"><p class="hint-container-title">Ezekre az utótagokra nem túl gyakran lesz szükségünk.</p></div><h3 id="szamjegy-szeparator" tabindex="-1"><a class="header-anchor" href="#szamjegy-szeparator" aria-hidden="true">#</a> Számjegy szeparátor</h3><p>Amikor az emberek hosszú számokat írnak, például <strong>1,000,000,000,000</strong>, gyakran használunk elválasztójelet, például vesszőt, hogy megkönnyítsük a szám értelmezését. Bár a C# nyelvben nem használhatjuk erre a célra a vesszőt, van egy alternatíva: az aláhúzás (<code>_</code>).</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">int</span></span> bigNumber <span class="token operator">=</span> <span class="token number">1_000_000_000</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>A számok írásakor a szokásos konvenció szerint hármas csoportosításban (<em>ezrek, milliók, milliárdok stb.</em>) írjuk őket, de a C# fordító nem törődik azzal, hogy ezek hol jelennek meg. Ha egy másik csoportosításnak több logikai értelme van, akkor használjuk úgy. A következők mindegyike megengedett:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">int</span></span> a <span class="token operator">=</span>  <span class="token number">123_456_789</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">int</span></span> b <span class="token operator">=</span> <span class="token number">12_34_56_78_9</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">int</span></span> c <span class="token operator">=</span> <span class="token number">1_2__3___4____5</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="az-egesz-tipusok-kozotti-valasztas" tabindex="-1"><a class="header-anchor" href="#az-egesz-tipusok-kozotti-valasztas" aria-hidden="true">#</a> Az egész típusok közötti választás</h3><p>Nyolc típus áll rendelkezésre az egész számok tárolására, de hogyan döntjük el, hogy melyiket használjuk?</p><p>Egyrészt gondosan megfontolhatjuk azokat az értéktartományokat, amelyekre szükségünk lehet bármely változónál. Majd kiválaszthatjuk a legrövidebbet <strong>-</strong> <em>a memóriahasználat csökkentése érdekében</em> <strong>-</strong> amely belefér az elképzelt tartományunkba.</p><p>Például, ha egy játékos pontszámára van szükségünk és tudjuk, hogy sosem lehet negatív, akkor már eleve kizártuk a nyolc lehetőségnek a felét. Ha a játékos pontszáma a százezreket is elérheti egy játék során, akkor kizárhatjuk a <code>byte</code> és <code>ushort</code> típusokat, mert azok nem elég nagyok. Ez csak az <code>uint</code> és <code>ulong</code> típusokat hagyja meg nekünk. Ha úgy gondoljuk, hogy a játékos pontszáma elérheti a 4 milliárdot, jobb, ha <code>ulong</code> típust használunk, de ha az adott értékek csak néhány milliót érnek el, akkor biztonságos az <code>uint</code> használata is. (<em>Mindig megváltoztathatjuk egy változó típusát és újra fordíthatjuk a programot, ha netán rosszul sikerült a típus kiválasztása - de könnyebb volna elsőre helyesen kiválasztani.</em>)</p><div class="hint-container danger"><p class="hint-container-title">Az a stratégia, hogy a legkisebb praktikus tartományt választjuk ki egy adott változóhoz, előnyös, de két dolog ellene szól.</p><p>Az első az, hogy a modern programozásban ritkán számít egyetlen bájtnyi hely megtakarítása. Túl sok memória van ahhoz, hogy az egyes bájtokon bosszankodjunk.</p><p>A második, hogy a számítógépek hardvere nem támogatja a kisebb típusokkal való matematikai műveleteket. A számítógép átalakítja őket <code>int</code>-ekké és a műveleteket <code>int</code>-ként futtatja, ami arra kényszerít minket, hogy ezután bajlódjunk azzal, hogy az eredményt visszaváltoztassuk a kisebb típusra. Az <code>int</code> típus kényelmesebb, mint az <code>sbyte</code>, <code>byte</code>, <code>short</code> és <code>ushort</code> típusok, ha sok matematikai műveletet végzünk.</p><p>Ezért a gyakran alkalmazott stratégia az, hogy <code>int</code>, <code>uint</code>, <code>long</code> vagy <code>ulong</code> típusokat használjunk szükség esetén és csak akkor alkalmazzuk a <code>byte</code>, <code>sbyte</code>, <code>short</code> és <code>ushort</code> típusokat, ha egyértelmű és jelentős előnye van.</p></div><h3 id="binaris-es-hexadecimalis-literalok" tabindex="-1"><a class="header-anchor" href="#binaris-es-hexadecimalis-literalok" aria-hidden="true">#</a> Bináris és hexadecimális literálok</h3><p>Eddig az egész szám literálok mind 10-es alapúak voltak, azaz a normális tízes számrendszerben, amit az emberek általában használnak. Azonban a programozási világban néha könnyebb lehet a számot bináris (<strong>2-es számrendszer</strong>) vagy hexadecimális (<strong>16-os számrendszer</strong>) alapon megadni, ahol a hexadecimális számok 0-tól 9-ig terjednek, majd a betűk A-tól F-ig.</p><p>Egy bináris literál létrehozásához kezdd a számot a 0b-vel. Például:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">int</span></span> thirteen <span class="token operator">=</span> <span class="token number">0b00001101</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Egy hexadecimális literál létrehozásához kezdd a számot 0x-szel:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">int</span></span> theColorMagenta <span class="token operator">=</span> <span class="token number">0xFF00FF</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Ez a példa mutatja, hol lehet hasznos ez. A színeket gyakran hat vagy nyolc hexadecimális számjeggyel reprezentálják.</p><h2 id="szoveg-karakterek-es-karakterlancok" tabindex="-1"><a class="header-anchor" href="#szoveg-karakterek-es-karakterlancok" aria-hidden="true">#</a> Szöveg: Karakterek és karakterláncok</h2><p>Van még pár numerikus típus, de most hagyjuk egy kicsit azokat és nézzük meg, hogyan lehet reprezentálni karaktereket és hosszabb szövegeket.</p><p>A C#-ban a <code>char</code> típus egyetlen karaktert reprezentál, míg a <code>string</code> a tetszőleges hosszúságú szöveget.</p><p>A <code>char</code> típus szorosan kapcsolódik az egész típusokhoz. A karakterek mindegyikéhez egy számot rendelünk, amely egyedi bitmintát jelent. A <code>char</code> típus nem csak billentyűzeti karakterekre korlátozódik. A <code>char</code> típus két bájtot használ, hogy <strong>65.536</strong> különböző karakter elférjen benne. Az egyes karakterekhez rendelt szám egy széles körben használt <strong>Unicode</strong> nevű szabványnak felel meg. Ez a készlet magában foglalja az angol karaktereket és minden ember által olvasható nyelv karaktereit, valamint egy egész sor más véletlenszerű karaktert és emojit. A <code>char</code> literális a karaktert egyszeres idézőjelbe helyezve készül:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">char</span></span> aLetter <span class="token operator">=</span> <span class="token char">&#39;a&#39;</span><span class="token punctuation">;</span> 
<span class="token class-name"><span class="token keyword">char</span></span> baseball <span class="token operator">=</span> <span class="token char">&#39;⚾&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><em>(A konzolablak azt a baseball karaktert nem tudja megjeleníteni.)</em></p><p>Ha ismerjük a szimbólum hexadecimális <strong>Unicode</strong> számát és azt szeretnénk használni akkor leírhatjuk egy <strong>\\u</strong> után:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">char</span></span> aLetter <span class="token operator">=</span> <span class="token char">&#39;\\u0061&#39;</span><span class="token punctuation">;</span> <span class="token comment">// An &#39;a&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>A <code>string</code> típus számos karaktert egy sorozatba gyűjt, hogy lehetővé tegye a tetszőleges szöveg reprezentálását. A <code>string</code> szó a matematika világából származik, ahol egy <code>string</code> egy szimbólumok sorozata, amelyeket egy meghatározott halmazból választanak ki, egymás után, tetszőleges hosszúságban. Ez egy olyan kifejezés, amit a programozási világ ellopott a matematika világából és a legtöbb programozási nyelv ezt az elképzelést <code>string</code>-nek nevezi.</p><p>A <code>string</code> literális úgy készül, hogy a kívánt szöveget dupla idézőjelbe helyezzük:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">string</span></span> message <span class="token operator">=</span> <span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="lebegopontos-tipusok" tabindex="-1"><a class="header-anchor" href="#lebegopontos-tipusok" aria-hidden="true">#</a> Lebegőpontos típusok</h2><p>Most visszatérünk a számok világához, hogy megvizsgáljuk azokat a típusokat, amelyek az egészen számokon kívül más számokat is képesek reprezentálni. Hogyan ábrázoljuk például a <strong>1.21</strong> gigawattot vagy a különleges <strong>π</strong> számot?</p><p>A C# három olyan típust tartalmaz, amelyeket lebegőpontos adattípusoknak nevezünk. Ezek a matematikusok által valós számoknak nevezett típusok, amelyek magukban foglalják az egészeket és az olyan számokat, amelyek tizedes vagy tört részt tartalmaznak. Habár nem tudnánk <strong>3.1415926</strong>-ot egy egész számként reprezentálni (<em>3 a legjobb, amit tehetnénk</em>), lebegőpontos számként már igen.</p><p>A lebegőpontos típusok esetében néhány bit tárolja a jelentős számjegyeket, befolyásolva a pontosságot, míg más bit-ek meghatározzák, hogy mennyire nagy vagy kicsi, befolyásolva az ábrázolt nagyságrendet.</p><p>Háromféle lebegőpontos szám típus létezik: <code>float</code>, <code>double</code> és <code>decimal</code>. A <code>float</code> típus <strong>4 bájtot</strong> használ, míg a <code>double</code> ennek kétszeresét (ezért a <code>double</code> név) <strong>8 bájt</strong>. A <code>decimal</code> típus <strong>16 bájtot</strong> használ. Míg a <code>float</code> és <code>double</code> a számítástechnika világában elfogadott konvenciókat követik, beleértve magát a számítógép áramkörét is, a <code>decimal</code> nem. Ez azt jelenti, hogy a <code>float</code> és <code>double</code> gyorsabbak. Azonban a <code>decimal</code> az előjeles számjegyek tárolására használja a legtöbb bitjét és a legpontosabb lebegőpontos típus. Ha olyan feladatot végzünk, amely rendkívüli pontosságot igényel, még a sebesség rovására is, a <code>decimal</code> a jobb választás.</p><p>Ebben a táblázatban összefoglaltam a lebegőpontos típusokat (<code>float</code>, <code>double</code>, <code>decimal</code>). A tárolt bájtok, tartomány, pontosság számjegyekben, valamint hardveres támogatás szempontjából.</p><table><thead><tr><th>Type</th><th>Bytes</th><th>Tartomány</th><th>Pontosság</th><th>Hardveres támogatás</th></tr></thead><tbody><tr><td><code>float</code></td><td>4</td><td>±1.0 × 10<sup>-45</sup> – ±3.4 × 10<sup>38</sup></td><td>7</td><td>Yes</td></tr><tr><td><code>double</code></td><td>8</td><td>±5 × 10<sup>-324</sup> – ±1.7 × 10<sup>308</sup></td><td>15-16</td><td>Yes</td></tr><tr><td><code>decimal</code></td><td>16</td><td>±1.0 × 10<sup>-28</sup> – ±7.9 × 10<sup>28</sup></td><td>28-29</td><td>No</td></tr></tbody></table><p>Az ilyen típusú változók létrehozása ugyanolyan, mint bármely más típusé, de érdekesebbé válik, amikor <code>float</code>, <code>double</code> és <code>decimal</code> literálokat hozunk létre:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">double</span></span> number1 <span class="token operator">=</span> <span class="token number">3.5623</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">float</span></span> number2 <span class="token operator">=</span> <span class="token number">3.5623f</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">decimal</span></span> number3 <span class="token operator">=</span> <span class="token number">3.5623m</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Ha egy szám literális tartalmaz egy tizedespontot, akkor az egy <code>double</code> literális lesz, nem pedig egész literális. A végéhez <code>f</code> vagy <code>F</code> hozzáfűzése egy <code>float</code> literállá teszi. Az <code>m</code> vagy <code>M</code> hozzáfűzése pedig decimális literálissá alakítja azt.</p><p>Mind a három típus nagyobb tartományt képes reprezentálni, mint bármely egész típus, így ha egy egész literált használunk, a fordító automatikusan átkonvertálja azt.</p><h2 id="a-bool-tipus" tabindex="-1"><a class="header-anchor" href="#a-bool-tipus" aria-hidden="true">#</a> A bool típus</h2><p>Az utolsó típus, amelyet itt tárgyalunk az a <code>bool</code> típus. A <code>bool</code> típus furcsának tűnhet, ha új vagy a programozásban, de hamarosan látni fogjuk az értékét. A <code>bool</code> típus a <strong>Boole-algebráról</strong> kapta a nevét, amelyet <em>George Boole</em>, a tervezője után neveztek el. A <code>bool</code> típus igazságértékeket reprezentál. Ezeket a döntéshozatalban használjuk és két lehetséges értéke van: <strong>true</strong> és <strong>false</strong>. Mindkettő <code>bool</code> literál, amit beleírhatunk a kódodba:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">bool</span></span> itWorked <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
itWorked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Néhány nyelv a <code>bool</code>-t nem kezelik másként, mint fantáziadús <code>int</code>-ként, ahol a <strong>false</strong> a <strong>0</strong> szám, a <strong>true</strong> pedig bármi más. A C# viszont elkülöníti az <code>int</code>-et a <code>bool</code>-tól, mert a kettő összekeverése sok általános hibakategóriához vezet.</p><p>Egy <code>bool</code> elméletileg csak egyetlen bitet használhatna, de ehelyett egy teljes bájtot használ.</p><h2 id="tipuskovetkeztetes" tabindex="-1"><a class="header-anchor" href="#tipuskovetkeztetes" aria-hidden="true">#</a> Típuskövetkeztetés</h2><p>Minden változónak, értéknek és kifejezésnek van egy meghatározott ismert típusa. A változók deklarálásakor nagyon pontosan megadtuk az egyes változók típusát. A fordító azonban nagyon okos - képes átnézni a kódot és a körülötte lévő jelekből és nyomokból kitalálni (de inkább <strong>kikövetkeztetni</strong>), hogy az milyen típusú. Ezt a funkciót típuskövetkeztetésnek nevezzük. Ez a fordító Sherlock Holmes-ja.</p><p>A típuskövetkeztetést számos nyelvi jellemzőre használják, de az egyik legjelentősebb az, hogy a fordító képes következtetni egy változó típusára a kód alapján, amellyel inicializálva van. Nem kell mindig magunknak kiírni egy változó típusát. Használhatjuk helyette a <code>var</code> kulcsszót:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">var</span></span> message <span class="token operator">=</span> <span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>A fordító képes észrevenni, hogy a <code>&quot;Hello, World!&quot;</code> egy karakterlánc és ezért a <code>message</code> változónak is karakterláncnak kell lennie ahhoz, hogy ez a kód működjön. A <code>var</code> használatával a fordítónak azt mondjuk, &quot;<em>Ez az, amit vársz. Tudom, hogy meg tudod oldani. Nem foglak untatni azzal, hogy magam írom le.</em>&quot;</p><p>Ez csak akkor működik, ha a változót ugyanazon a soron inicializáljuk, ahol deklaráljuk. Ellenkező esetben nincs elegendő információ a fordító számára ahhoz, hogy következtessen a típusára. Például ez nem fog működni:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">var</span></span> x<span class="token punctuation">;</span> <span class="token comment">// DOES NOT COMPILE!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Itt nincsenek utalások, amelyek megkönnyítenék a típuskövetkeztetést, így a típuskövetkeztetés sikertelen. Konkrét, elnevezett típusok használatára kell visszatérnünk.</p><p>A <strong>Visual Studio</strong>-ban könnyen láthatjuk, hogy a fordító milyen típusra következtetett, ha az egeret a <code>var</code> kulcsszó fölé visszük, amíg meg nem jelenik az eszköztár, amely megmutatja a következtetett típust.</p><p>Sok programozó előszeretettel használja a <code>var</code> kulcsszót mindenhol, ahol csak lehetséges. Gyakran rövidebb és tisztább, különösen akkor, amikor hosszabb nevű típusokkal kezdünk dolgozni.</p><p>Azonban két potenciális problémát is figyelembe kell venni a <code>var</code> használatakor. Az első az, hogy néha a számítógép rossz típust következtet. Ezek a hibák néha alig észrevehetőek. A második probléma az, hogy a számítógép gyorsabban következtet egy változó típusát, mint egy ember. Tekintsük meg ezt a kódot:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">var</span></span> input <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>A számítógép képes következtetni, hogy az <code>input</code> egy karakterlánc, mivel tudja, hogy a <code>ReadLine</code> karakterláncokat ad vissza. Az ilyen információk kinyerése sokkal nehezebb számunkra.</p><p>Egy <code>var</code>-ral definiált változó továbbra is egy konkrét típust használ. Ez nem egy rejtélyes típus, nem változtatható típus és nem egy mindenre jó típus. Továbbra is egy meghatározott típussal rendelkezik, csak épp nem írtuk le explicit módon. Ez a példa nem fog működni:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">var</span></span> something <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>
something <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// ERROR. Cannot store an int in a string-typed variable.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="a-convert-osztaly-es-a-parse-metodusok" tabindex="-1"><a class="header-anchor" href="#a-convert-osztaly-es-a-parse-metodusok" aria-hidden="true">#</a> A Convert osztály és a parse metódusok</h2><p>Mivel 14 típus áll rendelkezésünkre, néha szükségünk lesz a típusok közötti konverzióra. Ennek legegyszerűbb módja a <code>Convert</code> osztály. A <code>Convert</code> osztály olyan, mint a <code>Console</code> osztály - egy olyan dolog a rendszerben, amely egy sor feladatot vagy képességet biztosít, amelyet el tud végezni. A <code>Convert</code> osztály ezen különböző beépített típusok közötti konvertálásra szolgál. A következő példával illusztrálva:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code>Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token string">&quot;What is your favorite number?&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">string</span></span> favoriteNumberText <span class="token operator">=</span> Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">int</span></span> favoriteNumber <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>favoriteNumberText<span class="token punctuation">)</span><span class="token punctuation">;</span>
Console<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>favoriteNumber <span class="token operator">+</span> <span class="token string">&quot; is a great number!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Láthatjuk, hogy a <code>Convert.ToInt32</code> metódusa szövegként vár bemenetet és egy egész számot ad eredményként, az átalakítás folyamatában a szöveget konvertálva. A <code>Convert</code> osztálynak vannak <code>To...</code> metódusai, amelyek lehetővé teszik a beépített típusok közötti konvertálást:</p><table><thead><tr><th>Method Name</th><th>Target Type</th><th>Method Name</th><th>Target Type</th></tr></thead><tbody><tr><td>ToByte</td><td>byte</td><td>ToSByte</td><td>sbyte</td></tr><tr><td>ToInt16</td><td>short</td><td>ToUInt16</td><td>ushort</td></tr><tr><td>ToInt32</td><td>int</td><td>ToUInt32</td><td>uint</td></tr><tr><td>ToInt64</td><td>long</td><td>ToUInt64</td><td>ulong</td></tr><tr><td>ToChar</td><td>char</td><td>ToString</td><td>string</td></tr><tr><td>ToSingle</td><td>float</td><td>ToDouble</td><td>double</td></tr><tr><td>ToDecimal</td><td>decimal</td><td>ToBoolean</td><td>bool</td></tr></tbody></table><p>A fenti nevek többsége egyértelmű, bár néhányat érdemes megmagyarázni mivel a nevek nem tökéletesek...</p><p>A <code>short</code>, <code>int</code> és <code>long</code> típusok az <code>Int</code> szót és a hozzátartozó bitméretet használják. Például ha <code>short</code> típust <strong>16 bitet</strong> (<em>2 bájt</em>) használnánk, akkor a <code>ToInt16</code> használnánk. Az <code>ushort</code>, <code>uint</code> és <code>ulong</code> ugyanezt csinálja, csak az <code>UInt</code> kulcsszóval.</p><p>A másik meglepetés az, hogy egy lebegőpontos számra való átalakítás <code>ToSingle</code>, nem pedig <code>ToFloat</code>.</p><p>A konzolablakból származó összes <code>input</code> szöveg típusú. Sok programnak szüksége lesz arra, hogy átalakítsuk a felhasználó bekért szöveget egy másik típussá annak érdekében, hogy később azzal dolgozhassunk. A szöveg elemzésének, felbontásának és más adattípussá történő átalakításának folyamata <strong>parszolásnak</strong> (<em>parse</em>) nevezhető. A <code>Convert</code> osztály nagyszerű kiindulópont a szöveg <strong>parszolásához</strong>, bár idővel további parszolási eszközöket is tanulunk majd.</p><h3 id="parse-parszolasi-metodusok" tabindex="-1"><a class="header-anchor" href="#parse-parszolasi-metodusok" aria-hidden="true">#</a> Parse (parszolási) metódusok</h3><p>Néhány C# programozó kedveli a <code>Convert</code> osztály alternatíváját. Ezeknek a típusoknak sokszor van egy <code>Parse</code> nevű metódusa, amely segítségével egy szöveget tudunk átalakítanak. Például:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">int</span></span> number <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token string">&quot;9000&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Néhányan ezt a stílust részesítik előnyben a többnyire egyenértékű <code>Convert.ToInt32</code>-hez képest.</p><figure><img src="`+n+'" alt="Az itt látható diagram összefoglalja a C# típusrendszert. Ez tartalmazza mindazt, amit nagyjából tárgyaltunk és még jó néhány más típust és kategóriát is, amelyeket a jövőben fogunk tárgyalni." tabindex="0" loading="lazy"><figcaption>Az itt látható diagram összefoglalja a C# típusrendszert. Ez tartalmazza mindazt, amit nagyjából tárgyaltunk és még jó néhány más típust és kategóriát is, amelyeket a jövőben fogunk tárgyalni.</figcaption></figure>',107),r=[l];function k(d,i){return a(),s("div",null,r)}const g=e(o,[["render",k],["__file","lesson6.html.vue"]]);export{g as default};
